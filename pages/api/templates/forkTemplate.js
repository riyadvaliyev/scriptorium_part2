import prisma from '../../../utils/db';
import { verifyToken } from '../../../utils/verifyToken';
import { executingCode } from '../executeCode';

/*
As a visitor, I want to use an existing code template, run or modify it, 
and if desired, save it as a new template with a notification that it’s a 
forked version, so I can build on others’ work. Saving a template is only 
available to authenticated users.
*/

// THIS HAS BEEN TESTED. BUT IT IS ONLY FORKING. 
// THE "RUNNING" PART HAPPENS THROUGH NECERON'S CODE EXECUTION ENDPOINT.
// "MODIFYING" IT, AS A VISITOR (UNAUTHENTICATED), HAPPENS ON THE FRONTEND;
// NO CHANGES ARE REFLECTED ON THE BACKEND DUE TO THE NATURE OF THE VISITOR.

/**
 * 
 * @param {*} req 
 * @param {*} res 
 * @returns 
 */
export default async function handler(req, res) {
    // NOTE: 
    if (req.method === "POST") { // this is gonna be for saving (forking) a template
        const { title, explanation, language, tags, code, templateId } = req.body;

        const verified_token = verifyToken(req, res);

        if (!verified_token) {
            return res.status(401).json({ error: "Invalid token" });
        }

        // language check:
        if (!language || !["javascript", "python", "java", "c++", "c"].includes(language.toLowerCase())) {
            return res.status(400).json({ error: "Valid language is required." });
        }
        
        try {
            const user = await prisma.user.findUnique({
                where: {
                    id: verified_token.id
                }
            });
    
            if (!user) {
                return res.status(401).json({ error: "User not found" });
            }
    
            const template = await prisma.codeTemplate.findUnique({
                where: {
                    id: parseInt(templateId),
                }
            });
    
            if (!template) {
                return res.status(404).json({ error: "Template not found" });
            }
    
            const newTags = await Promise.all(
                tags.map(async (tag) => {
                    const existingTag = await prisma.tag.findUnique({
                        where: { name: tag.name },
                    });
                    return existingTag ? existingTag.id : (await prisma.tag.create({ data: { name: tag.name } })).id;
                })
            );
            
            // This code was generated by ChatGPT since I had no idea how to implement the new created attribute 
            const forkedTemplate = await prisma.codeTemplate.create({
                data: {
                    title,
                    explanation,
                    code,
                    userId: user.id,
                    language: language.toLowerCase(),
                    isForked: true,
                    tags: {
                        connect: newTags.map(tagId => ({ id: tagId }))
                    },
                    parentId: parseInt(template.id),  // This is the key attribute that indicates it's a forked version
                    // Children is implicitly empty since it's a new template
                }
            });
    
            if (!forkedTemplate) {
                return res.status(500).json({ error: "Failed to fork the Code Template." });
            }
    
            res.status(201).json({ template: forkedTemplate });
        } catch (error) {
            return res.status(500).json({ error: error.message });
        }
    } else {
        res.status(405).json({ message: "Must be a GET or POST method." });
    }
}